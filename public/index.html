<html lang="en">
  <head>
    <title>2D audio vizualization: volume meter</title>

        <style>
        .myCanvas {
  border:1px solid;
  margin-bottom:10px;
  margin-right:10px;
}

.main {
  margin: 32px;
  border:1px solid;
  border-radius:15px;
  background-color:lightGrey;
  padding:10px;
  box-shadow: 10px 10px 5px grey;
  text-align:center;
  font-family: "Open Sans";
  font-size: 12px;
}

div.controls label {
  display: inline-block;
  text-align: center;
  width: 50px;
}

div.controls label, div.controls input, output {
  vertical-align: middle;
  padding: 0;
  margin: 0;
  font-family: "Open Sans",Verdana,Geneva,sans-serif,sans-serif;
  font-size: 12px;
}

div.controls input[type=range] {
  margin-bottom:10px;
}
</style>
  </head>
<body>
	<h2>Vizualization of EDF-file</h2>
  <label for="file"></label><input type="file" id="file"  onchange="readFileContent(this.files,true)"/><br/>

 	<button onclick="makeCorsRequest('http://mainline.i3s.unice.fr/mooc/guitarRiff1.mp3');">
       Download  GuitarRiff
 	</button>
 	<button onclick="makeCorsRequest('http://aruner.net/resources/access-control-with-get/');">
       Download  arauranga
 	</button>
    <button onclick="makeCorsRequest('https://www.physionet.org/pn6/chbmit/chb04/chb04_11.edf');">
       edf - makeCorsRequest
  </button>


	<div id="myscreen" class="main" > <!--crossorigin="anonymous"-->
    <div class="controls">
      <label>Min X</label>
      <input type="range" value="0" step="0.05" min="0" max="1" oninput="setDrawMin(this.value);"></input>
      <output id="minTime">&nbsp;&nbsp;&nbsp;&nbsp;</output>

      <label>Max X</label>
      <input type="range" value="1" step="0.05" min="0" max="1" oninput="setDrawMax(this.value);"></input>
      <output id="maxTime">&nbsp;&nbsp;&nbsp;&nbsp;</output>
    </div>
		<canvas id="Canvas0" class="myCanvas" width=300 height=100></canvas>
	</div>
<p>

<textarea rows=15 cols=150 id="fileContent"></textarea> 

  <script >
 var width, height;
var showNo = 0;
var maxTime = 1;
var minTIme = 0;

// PHS
var headerLength;
var ns;
var signalColor = 'black';
var axisColor   = 'black';
var backgroundColor = 'white';

var canvases = [];
var canvasContexts = [];


window.onload = function() {
  var canvas  = document.getElementById("Canvas0");
  width = canvas.width;
  height = canvas.height;
  canvases[0] = canvas;
  canvasContexts[0] = canvas.getContext('2d');
};

function appendCanvases() {
  mainDiv = document.getElementById("myscreen");
  for (i =1; i < ns; ++i) {
    canvases[i] = canvases[0].cloneNode(true);
    canvases[i].setAttribute("id","");
    canvasContexts[i] = canvases[i].getContext('2d');;
    mainDiv.appendChild(canvases[i]);
  }
}

function readFileContent(files,binary)
{
  var reader = new FileReader();

  reader.onload = function(e) {
    var content = e.target.result;
    readEdvHeader(content);
    readEdvSignals(content,headerLength,signalHeaders);
    appendCanvases();
    for (i=0; i < ns; ++i) {
      drawWaveform(canvasContexts[i],signals[i], signalHeaders[i]);
    }
  };
  // Executed first: start reading the file asynchronously, will call the
  // reader.onload callback only when the file is read entirely
  reader.readAsArrayBuffer(files[0]);
}

function setDrawMin(newMinTime){
  minTime = newMinTime;
//  drawWaveform(signals[showNo], signalHeaders[showNo])
}

function setDrawMax(newMaxTime) {
  maxTime = newMaxTime;
 // drawWaveform(signals[showNo], signalHeaders[showNo])
}

function drawWaveform(canvasContext,signal, signalHeader) {
  clearCanvas(canvasContext);

  var showPct = 1;// maxTime-minTime;
console.log("showPct: "+showPct);
  var sliceWidth = width /(signalHeader.samplesCount*showPct);
  sigHeight = signalHeader.digitalMaximum-signalHeader.digitalMinimum;

  canvasContext.lineWidth = 1;
  canvasContext.strokeStyle = axisColor;
  canvasContext.beginPath();
  if (signalHeader.digitalMaximum >= 0 && signalHeader.digitalMinimum <= 0) {
    // draw zero line
    var y = height*(sigHeight + signalHeader.digitalMinimum )/ sigHeight;
    canvasContext.moveTo(0, y);
    canvasContext.lineTo(width, y);
  }
  canvasContext.stroke();  
  
  canvasContext.beginPath(); 
  canvasContext.lineWidth = 1;
  canvasContext.strokeStyle = signalColor;
  var x = 0;
  for(var i = 0; i < signalHeader.samplesCount; i++) {
 //   console.log(i+" "+signal[i]);
     var y = height*(sigHeight - (signal[i]-signalHeader.digitalMinimum) )/ sigHeight;
    
     if(i === 0) {
        canvasContext.moveTo(x, y);
     } else {
        canvasContext.lineTo(x, y);
     }
     x += sliceWidth;
  }
  canvasContext.stroke(); 

  canvasContext.restore();
}

function clearCanvas(canvasContext) {
   canvasContext.save();
  
  canvasContext.fillStyle =  backgroundColor;
  canvasContext.fillRect(0, 0, width, height);
  
  canvasContext.restore();
}

function readEdvSignals(content,startPos,signalHeaders)
{
  signals = [];
  var i;
  //console.log("startpos: "+startPos)
  for ( i = 0, pos = startPos; i < ns; ++i) {
      signals[i] = new Int16Array(content,pos,signalHeaders[i].samplesCount);
      pos +=  2*signalHeaders[i].samplesCount;
      //console.log("pos: "+pos)
  } ;
}

function readEdvHeader(buffer)
{

  var header = String.fromCharCode.apply(null, new Uint8Array(buffer.slice(0,192)));

//HEADER RECORD (we suggest to also adopt the 12 simple additional EDF+ specs)
  pos = 0; var len = 0; 
  version ="";
  readVersion(header,pos);
  // afgør om der skal fortsættes
  console.log("version: "+version+" "+parseInt(version))
  if (parseInt(version) != 0) {
    console.log("This software only handles EPS");
  }

  // read fixed header1
  len = 80; var patientId    = header.substring(pos,pos+len-1);  pos+=len;//80 ascii : local patient identification (mind item 3 of the additional EDF+ specs); pos+=len;
  len = 80; var recordingId  = header.substring(pos,pos+len-1);  pos+=len;//80 ascii : local recording identification (mind item 4 of the additional EDF+ specs); pos+=len;
  len =  8; var startDate    = header.substring(pos,pos+len-1);  pos+=len;//8 ascii : startdate of recording (dd.mm.yy) (mind item 2 of the additional EDF+ specs); pos+=len;
  len =  8; var startime     = header.substring(pos,pos+len-1);  pos+=len;//8 ascii : starttime of recording (hh.mm.ss); pos+=len;
  len =  8; headerLength     = parseInt(header.substring(pos,pos+len-1));  pos+=len;//parseInt(header.substring(184,191)); // var 8 ascii : number of bytes in header record

  header   = String.fromCharCode.apply(null, new Uint8Array(buffer.slice(0,headerLength-1)));
//  document.getElementById("fileContent").value=fullheader;

  // read fixed header2
  len = 44; var reservedField = header.substring(pos,pos+len-1);  pos+=len; //44 ascii : reserved 
  len =  8; var numberOfData = header.substring(pos,pos+len-1);  pos+=len;  //8 ascii : number of data records (-1 if unknown, obey item 10 of the additional EDF+ specs) 
  len =  8; var duration     = header.substring(pos,pos+len-1);  pos+=len;  //8 ascii : duration of a data record, in seconds 
  len =  4; ns           = header.substring(pos,pos+len-1);  pos+=len;  //4 ascii : number of signalHeaders (ns) in data record

  signalHeaders = [];
  if (ns <= 0) {
      console.log("no signals");
  } else {

    readSignalHeaders(header,ns);
  }

  document.getElementById("fileContent").value = JSON.stringify(signalHeaders);

}

function readVersion(header)
{
  len = 8; version      = header.substring(pos,pos+len-1);  pos+=len;//  8 ascii : version of this data format (0);  
}

function readSignalHeaders(header,ns)
{
  var i = 0;
  for ( i = 0; i < ns; ++i) {
    signalHeaders[i] = {};
   //console.log(signalHeaders[i])
  } ;
    console.log(signalHeaders[ns-1])
  // ns * 16 ascii : ns * label (e.g. EEG Fpz-Cz or Body temp) (mind item 9 of the additional EDF+ specs)
  len = 16; 
  for ( i = 0; i < ns; ++i) {
      signalHeaders[i].label = header.substring(pos,pos+len-1);
      pos+=len;
  } ;

  // ns * 80 ascii : ns * transducer type (e.g. AgAgCl electrode) 
  len = 80; 
  for ( i = 0; i < ns; ++i) {
      signalHeaders[i].transducerType = header.substring(pos,pos+len-1);
      pos+=len;
  } ;

    // ns * 8 ascii : ns * physical dimension (e.g. uV or degreeC) 
  len = 8; 
  for ( i = 0; i < ns; ++i) {
      signalHeaders[i].physicalDimension = header.substring(pos,pos+len-1);
      pos+=len;
  } ;

   // ns * 8 ascii : ns * physical minimum (e.g. -500 or 34) 
  len = 8; 
  for ( i = 0; i < ns; ++i) {
      signalHeaders[i].physicalMinimum = parseFloat(header.substring(pos,pos+len-1));
      pos+=len;
  } ;

   // ns * 8 ascii : ns * physical maximum (e.g. 500 or 40) 
  len = 8; 
  for ( i = 0; i < ns; ++i) {
      signalHeaders[i].physicalMaximum = parseFloat(header.substring(pos,pos+len-1));
      pos+=len;
  } ;

    // ns * 8 ascii : ns * digital minimum (e.g. -2048) 
  len = 8; 
  for ( i = 0; i < ns; ++i) {
      signalHeaders[i].digitalMinimum = parseInt(header.substring(pos,pos+len-1));
      pos+=len;
  } ;

   // ns * 8 ascii : ns * digital maximum (e.g. 2047) 
   len = 8; 
  for ( i = 0; i < ns; ++i) {
      signalHeaders[i].digitalMaximum = parseInt(header.substring(pos,pos+len-1));
      pos+=len;
  } ;

   // ns * 80 ascii : ns * prefiltering (e.g. HP:0.1Hz LP:75Hz) 
  len = 80; 
  for ( i = 0; i < ns; ++i) {
      signalHeaders[i].prefiltering = header.substring(pos,pos+len-1);
      pos+=len;
  } ;

  // ns * 8 ascii : ns * nr of samples in each data record 
  len = 8; 
  for ( i = 0; i < ns; ++i) {
      signalHeaders[i].samplesCount = parseInt(header.substring(pos,pos+len-1));
      pos+=len;
  } ;

  // ns * 32 ascii : ns * reserved
  len = 32; 
  for ( i = 0; i < ns; ++i) {
      signalHeaders[i].reserved = header.substring(pos,pos+len-1);
      pos+=len;
  } ;
}

//---------------------------------------------------------------------------------
// Load a binary file from a URL as an ArrayBuffer.
function downloadFile(url) {
  //var xhr = new XMLHttpRequest();
  var xhr = createCORSRequest('GET', url);
  if (!xhr) {
    throw new Error('CORS not supported');
  }


  xhr.open('GET', url, true);

  xhr.responseType = 'arraybuffer'; // THIS IS NEW WITH HTML5!
  xhr.onload = function(e) {
    console.log("Song downloaded, decoding...");
//    initSound(this.response); // this.response is an ArrayBuffer.
  };
  xhr.onerror = function(e) {
    console.log("error downloading file");
  }

  xhr.send();
  console.log("Ajax request sent... wait until it downloads completely");
}

// eksempel 1 fra internet

// Create the XHR object.
function createCORSRequest(method, url) {
  var xhr = new XMLHttpRequest();

  if ("withCredentials" in xhr) {
    // XHR for Chrome/Firefox/Opera/Safari.
    xhr.open(method, url, true);
  } else if (typeof XDomainRequest != "undefined") {
    // XDomainRequest for IE.
    xhr = new XDomainRequest();
    xhr.open(method, url);
  } else {
    // CORS not supported.
    xhr = null;
  }

  return xhr;
}

// Helper method to parse the title tag from the response.
function getTitle(text) {
  return text.match('<title>(.*)?</title>')[1];
}

// Make the actual CORS request.
function makeCorsRequest(url) {
  // All HTML5 Rocks properties support CORS.
  //var url = 'http://updates.html5rocks.com';

  var xhr = createCORSRequest('GET', url);

  if (!xhr) {
    alert('CORS not supported');
    return;
  }

  // Response handlers.
  xhr.onload = function() {
    var text = xhr.responseText;
//    var title = getTitle(text);
    var title = "test"
    alert('Response from CORS request to ' + url + ': ' + title);
  };

  xhr.onerror = function() {
    alert('Woops, there was an error making the request.');
  };

  //xhr.withCredentials = true;      // AALOWS COOKIES. Server must also allow. Set only when cookies are needed

  xhr.send();
}
//--------------------------------------------------------------------------------------   

  </script>

</body>
</html>